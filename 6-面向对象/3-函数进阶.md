# 目标

* 能够说出函数的多种定义和调用方式
* 能够说出和改变函数内部的`this`指向
* 能够说出严格模式的特点
* 能够把函数作为参数和返回值传递
* 能够说出闭包的作用
* 能够说出递归的两个条件
* 能够说出深拷贝和浅拷贝的区别

# 1. 函数的定义和调用

### 1.1 函数的定义方式

* 函数声明方式`function`关键字（命名函数）

* 函数表达式（`匿名函数`）

* 利用`new Function('参数1', '参数2', ..., '函数体')`创建函数（这个方法很少使用）

  ```javascript
  var fn = new Function('参数1','参数2',...,'函数体') // 参数一定要是字符串类型
  ```

> 注意：所有的函数都是 Function 的实例（对象）

![函数也是对象](resource/hanshujinjie1.jpg)

### 1.2 函数的调用方式

* 普通函数
* 对象的方法
* 构造函数
* 绑定事件函数
* 定时器函数
* 立即执行函数

##### 1. 普通函数

```javascript
function fn() {
    console.log("hello");
}
```

> 调用：

`fn()`或者`fn.call()`

##### 2. 对象的方法

```javascript
function fn() {
    var obj = {
        hello: function() {
        console.log("hello");
        },
    };
}
```

> 调用：

`obj.hello()`

##### 3. 构造函数

```javascript
function Person(age) {
    this.age = age;
}
```

> 调用：

`new Person()`

##### 4. 绑定事件函数

```javascript
btn.onclick = function() {
    console.log("hello");
};
```

> 调用：

触发事件即可调用

##### 5. 定时器函数

```javascript
setTimeout(function() {
    console.log("hello");
}, 1000);
```

> 调用：

定时器触发调用

##### 6. 立即执行函数

```javascript
(function() {
    console.log("hello");
})();
```

> 调用：

不需要调用，自己即可执行

# 2. this

### 2.1 函数内部的this指向

这些`this`的指向，是当我们调用函数的时候确定的。调用方式的不同决定了`this`的指向不同。一般指向我们的`调用者`

| 调用方式     | this指向                                  |
| ------------ | ----------------------------------------- |
| 普通函数调用 | window                                    |
| 构造函数调用 | 实例对象 原型对象里面的方法也指向实例对象 |
| 对象方法调用 | 该方法所属的对象                          |
| 事件绑定方法 | 绑定事件对象                              |
| 定时器函数   | window                                    |
| 立即执行函数 | window                                    |

### 2.2 改变函数内部的this指向

JS为我们提供了一些函数来帮助我们处理函数的内部`this`的指向问题，常用的有`call()`、`bind()`和`apply()`

##### 1. call

 `call()`方法`调用`一个对象。简单理解为调用函数的方式，但是它可以改变函数的 this 指向。

```javascript
fun.call(thisArg, arg1, arg2, ...);
```

我们还可使用`call`来实现`继承`

##### 2. bind

`bin()`方法`不会调用`函数，但是能改变函数里面的 this 指向

```javascript
fun.bind(thisArg, arg1, arg2)
```

* thisArg：在fun函数运行时指定的`this`值
* arg1, arg2：传递的其他参数
* 返回由指定的this值和初始化参数改造的`原函数的拷贝`

##### 3. apply

 `apply()`方法`调用`一个对象。简单理解为调用函数的方式，但是它可以改变函数的 this 指向。

```javascript
fun.apply(thisArg, [argsArray]);
```

* thisArg：在fun函数运行时指定的`this`值
* argsArray：传递的值，比如包含在`数组`种
* 返回值就是`函数的返回值`，因为它的调用函数

> apply的主要应用

我们可以用`apply`借助于数学内置对象求最大值

```javascript
var arr = [1, 22, 33, 5, 7, 9];
console.log(Math.max.apply(Math, arr));
```

##### 4. bind的使用场景

如果有的函数我们不需要立即调用，但是又想改变这个函数内部的`this指向`，此时使用`bind`方法最合适

> 例子：

```javascript
var btn = document.querySelector("button");
btn.addEventListener("click", function() {
    this.disabled = true;
    setTimeout(
        function() {
            // 但是由于我们的定时器的this指向的是window，所以需要我们手动更改一下
            this.disabled = false;
        }.bind(this), // 所以我们要手动更改
        3000
    );
});
```

### 2.3 call apply bind 总结

##### 相同点：

都可以改变函数内部的`this`指向

##### 区别点：

1. `call`和`apply`会调用函数，并改变函数的`this`指向
2. `call`和`apply`传递的参数不同，`call`传递参数`aru1`,`aru2`...。但是`apply`必须`数组`格式
3. `bind`不会调用函数，可以改变函数内部的`this`指向（不会改变原函数，会返回一个改变指数的`原函数拷贝`）

##### 主要应用场景：

1. `call`经常做`继承`
2. `apply`经常和`数组`有关系，比如借助于数学对象实现数组最大值和最小值
3. `bind`由于不调用函数，所以有时候我们可以更改`定时器`内部的this

# 3. 严格模式

### 3.1 什么是严格模式

JS除了提供正常模式外，还提供了`严格模式(strict mode)`。ES5的严格模式是采用具有先执行的JavaScript变体的一种方式，即在严格的条件下运行JS代码。

严格模式在`IE10+`版本支持，旧版本浏览器会直接忽略

严格模式对正常的JavaScript语法做了一些更改：

1. 消除了JS语法的一些不合理、不严谨之处，减少了一些怪异行为
2. 消除了代码运行的一些不安全之处，保证代码运行的安全
3. 提高编译器效率，增加运行速度
4. 禁用了在EMCAScript的未来版本中可能会定义的一些语法，为未来版本做好铺垫。比如一些保留字如：`class`、`enum`、`export`、`extends`、`import`、`super`不能做变量名。

### 3.2 开启严格模式

严格模式可以应用到`整个脚本`或者`个别函数`中。因此在使用时，我们可以把严格模式区分为`为脚本打开严格模式`和`为函数打开严格模式`两种情况

##### 1. 为脚本开启严格模式

为整个脚本文件开启严格模式。需要在所有语句前加上特定语句`"use strict";`或者`'use strict';`

但是有的JS文件是严格模式，有的不是严格模式，这样不利于文件合并。所以我们可以在立即执行函数中添加开启严格模式，这样就创建了一个独立的作用域，不会污染别的JS文件

```javascript
(function(){
    "use strict";
    // code here
})();
```

##### 2. 给某个函数开启严格模式

在函数体所有执行语句前添加`"use strict";`或`'use strict';`

```javascript
function fn() {
    // 里面的按照普通模式执行
}

function fn2() {
    "use strict";
    // 下面的代码按照严格模式执行
}
```

### 3.3 严格模式的变化

严格模式对JS的`语法`和`行为`，都做了一些改变

##### 1. 变量规定

> 在正常模式下，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，所以变量`必须先声明`，然后才能使用

> 严禁删除已经声明的变量。例如`delete num;`这个语法是错误的。

##### 2. this 的指向问题

> 正常模式下全局作用域中`普通函数`的`this`指向`window`
>
> 严格模式下全局作用域中`普通函数`的`this`指向`undefined`（未指定this前）

> 正常模式下`构造函数`不加new`也能调用`，当普通函数，`this`指向`window`
>
> 严格模式下`构造函数`不加new`不能调用`，加new，`this`指向`实例对象`

> 严格模式下`定时器函数`的`this`仍然指向`window`

##### 3. 函数变化

> 函数里的参数`不允许有重名`情况

> 函数必须声明在顶层，新版本的JS会引入“块级作用域”（ES6中已引入），为了和新版本接轨，不允许在非函数的代码块内声明函数

```javascript
"use strict";
var a = 10;
if(a != 0){
	function fn(){};  // 语法错误 
}

for(var i=0;i<a.length;i++){
 	function fn(){};  // 语法错误   
}

function fn1(){
    function fn2(){};  // 合法
}
```

更多严格模式的要求请参考：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode

